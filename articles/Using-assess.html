<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Postestimation: Assessing a model • cSEM</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Postestimation: Assessing a model">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-156347841-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-156347841-1');
</script>
</head>
<body data-spy="scroll" data-target="#toc">


    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">cSEM</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">0.5.0.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/cSEM.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles

    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Notation.html">Notation</a>
    </li>
    <li>
      <a href="../articles/Terminology.html">Terminology</a>
    </li>
    <li>
      <a href="../articles/Using-assess.html">Postestimation: Assessing a model</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/FloSchuberth/cSEM/" class="external-link">
    <span class="fab fa-github fa-lg"></span>

  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->



      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Postestimation: Assessing a model</h1>
            <h3 data-toc-skip class="subtitle">Using the
<code>assess()</code> function</h3>
                        <h4 data-toc-skip class="author">Manuel
Rademaker</h4>
            
            <h4 data-toc-skip class="date">Last edited: 2025-01-14</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/FloSchuberth/cSEM/blob/master/vignettes/Using-assess.Rmd" class="external-link"><code>vignettes/Using-assess.Rmd</code></a></small>
      <div class="hidden name"><code>Using-assess.Rmd</code></div>

    </div>

    
    
<!-- used to print boldface greek symbols (\mathbf only works for latin symbols) -->
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>As indicated by the name, <code><a href="../reference/assess.html">assess()</a></code> is used to assess a
model estimated using the <code><a href="../reference/csem.html">csem()</a></code> function.</p>
<p>In <strong>cSEM</strong> model assessment is considered to be any
task that in some way or another seeks to assess the quality of the
estimated model <em>without conducting</em> <em>a statistical test</em>
(tests are covered by the <code>test_*</code> family of functions).
Quality in this case is taken to be a catch-all term for all common
aspects of model assessment. This mainly comprises fit indices, model
selection criteria, reliability estimates, common validity assessment
criteria, effect sizes, and other related quality measures/indices that
do not rely on a formal test procedure. Hereinafter, we will refer to a
generic (fit) index, quality or assessment measure as a <strong>quality
criterion</strong>.</p>
<p>Currently the following quality criteria are implemented:</p>
<ul>
<li>Convergent and discriminant validity assessment:
<ul>
<li>The <strong>average variance extracted</strong> (AVE)</li>
<li>The <strong>Fornell-Larcker</strong> criterion</li>
<li>The <strong>heterotrait-monotrait ratio of correlations</strong>
(HTMT)</li>
</ul>
</li>
<li>
<strong>Congeneric reliability</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>C</mi></msub><annotation encoding="application/x-tex">\rho_C</annotation></semantics></math>),
also known as e.g.: composite reliability, construct reliability,
(unidimensional) omega, Jöreskog’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\rho_A</annotation></semantics></math>,
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>B</mi></msub><annotation encoding="application/x-tex">\rho_B</annotation></semantics></math>.</li>
<li>
<strong>Tau-equivalent reliability</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\rho_T</annotation></semantics></math>),
also known as e.g.: Cronbach alpha, alpha,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
coefficient alpha, Guttman’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mn>3</mn></msub><annotation encoding="application/x-tex">\lambda_3</annotation></semantics></math>,
KR-20.</li>
<li>Distance measures
<ul>
<li>The <strong>standardized root mean square residual</strong>
(SRMR)</li>
<li>The <strong>geodesic distance</strong> (DG)</li>
<li>The <strong>squared Euclidian distance</strong> (DL)</li>
<li>The <strong>maximum-likelihood distance</strong> (DML)</li>
</ul>
</li>
<li>Fit indices
<ul>
<li>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>-<strong>statistic</strong>
</li>
<li>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup><mi>/</mi><mi>d</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\chi^2/df</annotation></semantics></math>-<strong>statistic</strong>
</li>
<li>The <strong>comparative fit index</strong> (CFI)</li>
<li>The <strong>goodness-of-fit index</strong> (GFI)</li>
<li>The <strong>standardized root mean square residual</strong>
(SRMR)</li>
<li>The <strong>root mean square error of approximation</strong>
(RMSEA)</li>
<li>The <strong>normed fit index</strong> (NFI)</li>
<li>The <strong>non-normed fit index</strong> (NNFI)</li>
<li>The <strong>comparative fit index</strong> (CFI)</li>
<li>The <strong>incremental fit index</strong> (IFI)</li>
<li>The <strong>root mean square outer residual covariance</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">RMS</mtext><mi>θ</mi></msub><annotation encoding="application/x-tex">\text{RMS}_{\theta}</annotation></semantics></math>)</li>
</ul>
</li>
<li>The <strong>Goodness-of-Fit</strong> (GoF) proposed by <span class="citation">Tenenhaus, Amanto, and Vinzi (2004)</span>.</li>
<li>The <strong>variance inflation factors</strong> (VIF) for the
structural equations as well as for Mode B regression equations (if
<code>.approach_weights = "PLS-PM"</code>).</li>
<li>The coefficient of determination and the adjusted coefficient of
determination
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>R</mi><mn>2</mn></msup><annotation encoding="application/x-tex">R^2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>R</mi><mrow><mi>a</mi><mi>d</mi><mi>j</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">R^2_{adj}</annotation></semantics></math>)</li>
<li>A measure of the <strong>effect size</strong> (Cohen’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mn>2</mn></msup><annotation encoding="application/x-tex">f^2</annotation></semantics></math>).</li>
<li>Direct, indirect and total effect assessment.</li>
<li>Several model selection criteria as described in <span class="citation">Sharma et al. (2019)</span>.</li>
</ul>
<p>For implementation details see the <a href="#methods">Methods &amp;
Formulae</a> section.</p>
</div>
<div class="section level2">
<h2 id="syntax-options">Syntax &amp; Options<a class="anchor" aria-label="anchor" href="#syntax-options"></a>
</h2>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/assess.html">assess</a></span><span class="op">(</span></span>
<span>  .object              <span class="op">=</span> <span class="cn">NULL</span>, </span>
<span>  .only_common_factors <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>  .quality_criterion   <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"all"</span>, <span class="st">"aic"</span>, <span class="st">"aicc"</span>, <span class="st">"aicu"</span>, <span class="st">"bic"</span>, <span class="st">"fpe"</span>, <span class="st">"gm"</span>, <span class="st">"hq"</span>,</span>
<span>                           <span class="st">"hqc"</span>, <span class="st">"mallows_cp"</span>, <span class="st">"ave"</span>,</span>
<span>                           <span class="st">"rho_C"</span>, <span class="st">"rho_C_mm"</span>, <span class="st">"rho_C_weighted"</span>, </span>
<span>                           <span class="st">"rho_C_weighted_mm"</span>, <span class="st">"dg"</span>, <span class="st">"dl"</span>, <span class="st">"dml"</span>, <span class="st">"df"</span>,</span>
<span>                           <span class="st">"effects"</span>, <span class="st">"f2"</span>, <span class="st">"fl_criterion"</span>, <span class="st">"chi_square"</span>, <span class="st">"chi_square_df"</span>,</span>
<span>                           <span class="st">"cfi"</span>, <span class="st">"gfi"</span>, <span class="st">"ifi"</span>, <span class="st">"nfi"</span>, <span class="st">"nnfi"</span>, </span>
<span>                           <span class="st">"reliability"</span>,</span>
<span>                           <span class="st">"rmsea"</span>, <span class="st">"rms_theta"</span>, <span class="st">"srmr"</span>,</span>
<span>                           <span class="st">"gof"</span>, <span class="st">"htmt"</span>, <span class="st">"r2"</span>, <span class="st">"r2_adj"</span>,</span>
<span>                           <span class="st">"rho_T"</span>, <span class="st">"rho_T_weighted"</span>, <span class="st">"vif"</span>, </span>
<span>                           <span class="st">"vifmodeB"</span><span class="op">)</span>,</span>
<span>  <span class="va">...</span></span>
<span><span class="op">)</span></span></code></pre></div>
<dl>
<dt><code>.object</code></dt>
<dd>
<p>An object of class <code>cSEMResults</code> resulting from a call to
<code><a href="../reference/csem.html">csem()</a></code>.</p>
</dd>
<dt><code>.quality_criterion</code></dt>
<dd>
<p>A character string or a vector of character strings naming the
quality criterion to compute. By default all quality criteria are
computed (<code>"all"</code>). See <code><a href="../reference/assess.html">assess()</a></code> for a list of
possible candidates.</p>
</dd>
<dt><code>.only_common_factors</code></dt>
<dd>
<p>Logical. Should only concepts modeled as common factors be included
when calculating one of the following quality criteria: AVE, the
Fornell-Larcker criterion, HTMT, and all reliability estimates. Defaults
to <code>TRUE</code>.</p>
</dd>
<dt><code>...</code></dt>
<dd>
<p>Further arguments passed to functions called by
<code><a href="../reference/assess.html">assess()</a></code>. See <a href="https://floschuberth.github.io/cSEM/reference/args_assess_dotdotdot.html" class="external-link">args_assess_dotdotdot</a>
for a complete list of available arguments.</p>
</dd>
</dl>
<p>Like all postestimation functions <code><a href="../reference/assess.html">assess()</a></code> can be called
on any object of class <code>cSEMResults</code>. The output is a named
list of the quality criteria given to <code>.quality_criterion</code>.
By default all possible quality criteria are calculated
(<code>.quality_criterion = "all"</code>).</p>
<div class="section level3">
<h3 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a>
</h3>
<p>In line with all of <strong>cSEM</strong>’s postestimation functions,
<code><a href="../reference/assess.html">assess()</a></code> is a generic function with methods for objects of
class <code>cSEMResults_default</code>, <code>cSEMResults_multi</code>,
<code>cSEMResults_2ndorder</code>. In <strong>cSEM</strong> every
<code>cSEMResults_*</code> object must also have class
<code>cSEMResults</code> for internal reasons. When using one of the
major postestimation functions, method dispatch is therefore technically
done on one of the <code>cSEMResults_*</code> class attributes, ignoring
the <code>cSEMResults</code> class attribute. As long as
<code><a href="../reference/assess.html">assess()</a></code> is used directly, method dispatch is not of any
practical concern to the end-users.
<!-- The difference, however, becomes important if a user seeks to directly invoke an  -->
<!-- internal function which is called by `assess() ` (e.g., `cSEM:::calculateAVE()` or  -->
<!-- `cSEM:::calculateHTMT()`).  -->
<!-- In this case only objects of class `cSEMResults_default` are accepted as this -->
<!-- ensures a specific structure. Therefore, it is important to remember that -->
<!-- *internal functions in **cSEM** are generally **not** generic*! --></p>
<!-- > Update (24.02.2020): from version 0.2.0 onwards all functions that assess() calls internally -->
<!--   will be exported. This mean users can directly invoke functions such as e.g., -->
<!--   `calculateHTMT()` or `calculateRhoT()`. These functions will also be generic  -->
<!--   accepting all types of cSEMResults classes. -->
<div class="section level4">
<h4 id="composite-models-vs--common-factor-models">Composite models vs. common factor models<a class="anchor" aria-label="anchor" href="#composite-models-vs--common-factor-models"></a>
</h4>
<p>Some assessment measures are inherently tied to the common factor
model. It is therefore unclear how to interpret their results in the
context of a composite model. Consequently, their computation is
suppressed by default for constructs modeled as composites. Currently,
this applies to the following quality criteria:</p>
<ul>
<li>AVE and validity assessment based thereon (i.e., the Fornell-Larcker
criterion)</li>
<li>HTMT and validity assessment based thereon</li>
<li>All reliability measures</li>
</ul>
<p>It is possible to force computation of all quality criteria for
constructs modeled as composites using
<code>.only_common_factors = FALSE</code>, however, we explicitly warn
to interpret results, as they may not even have a conceptual
meaning.</p>
<p>All quality criteria assume that the estimated loadings, construct
correlations and path coefficients involved in the computation of a
specific quality measure are consistent estimates for their theoretical
population counterpart. If the user deliberately chooses an approach
that yields inconsistent estimates (by setting
<code>.disattenuate = FALSE</code> in <code><a href="../reference/csem.html">csem()</a></code> when the
estimated model contains constructs modeled as common factors)
<code><a href="../reference/assess.html">assess()</a></code> will still estimate all quantities, however,
quantities such as the AVE or the congeneric reliability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>C</mi></msub><annotation encoding="application/x-tex">\rho_C</annotation></semantics></math>
inherit inconsistency.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="methods">Methods &amp; Formulae<a class="anchor" aria-label="anchor" href="#methods"></a>
</h2>
<p>This section provides technical details and relevant formulae. For
the relevant notation and terminology used in this section, see the <a href="https://floschuberth.github.io/cSEM/articles/Notation.html" class="external-link">Notation</a>
and the <a href="https://floschuberth.github.io/cSEM/articles/Terminology.html" class="external-link">Termionology</a>
help files.</p>
<div class="section level3">
<h3 id="ave">Average Variance Extracted (AVE)<a class="anchor" aria-label="anchor" href="#ave"></a>
</h3>
<div class="section level4">
<h4 id="definition">Definition<a class="anchor" aria-label="anchor" href="#definition"></a>
</h4>
<p>The average variance extracted (AVE) was first proposed by <span class="citation">Fornell and Larcker (1981)</span>. Several definitions
exist. For ease of comparison to extant literature the most common
definitions are given below:</p>
<ul>
<li>The AVE for a generic construct/latent variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is an estimate of how much of the variation of its indicators is due to
the assumed latent variable. Consequently, the share of unexplained,
i.e. error variation is 1 - AVE.</li>
<li>The AVE for a generic construct/latent variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is the share of the total indicator variance (i.e., the sum of the
indicator variances of all indicators connected to the construct), that
is captured by the (indicator) true scores.</li>
<li>The AVE for a generic construct/latent variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is the ratio of the sum of the (indicator) true score variances
(explained variation) relative to the sum of the total indicator
variances (total variation, i.e., the sum of the indicator variances of
all indicators connected to the construct).</li>
<li>Since for the regression of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>k</mi></msub><annotation encoding="application/x-tex">x_k</annotation></semantics></math>
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\eta_k</annotation></semantics></math>,
the R squared
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>R</mi><mi>k</mi><mn>2</mn></msubsup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">R^2_k)</annotation></semantics></math>
is equal to the share of variation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>k</mi></msub><annotation encoding="application/x-tex">x_k</annotation></semantics></math>
explained by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\eta_k</annotation></semantics></math>
relative to the total variation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>k</mi></msub><annotation encoding="application/x-tex">x_k</annotation></semantics></math>,
the AVE for a generic construct/latent variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is equal to the average over all
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>R</mi><mi>k</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">R^2_k</annotation></semantics></math>.</li>
<li>The AVE for a generic construct/latent variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>
is the sum of the squared correlation between indicator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>k</mi></msub><annotation encoding="application/x-tex">x_k</annotation></semantics></math>
and the (indicator) true score
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\eta_k</annotation></semantics></math>
relative to the sum of the indicator variances of all indicators
connected to the construct in question.</li>
</ul>
<p>It is important to stress that, although different in wording, all
definitions are synonymous!</p>
<p>The AVE is inherently tied to the common factor model. It is
therefore unclear how to interpret the AVE for constructs modeled as
composites. Consequently, the computation is suppressed by default for
constructs modeled as common factors. It is possible to force
computation of the AVE for constructs modeled as composites using
<code>.only_common_factors = FALSE</code>, however, we explicitly warn
to interpret results, as they may not even have a conceptual
meaning.</p>
</div>
<div class="section level4">
<h4 id="formulae">Formulae<a class="anchor" aria-label="anchor" href="#formulae"></a>
</h4>
<p>Using the results and notation derived and defined in the <a href="https://floschuberth.github.io/cSEM/articles/Notation.html" class="external-link">Notation</a>
help file, the AVE for a generic construct is:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>V</mi><mi>E</mi><mo>=</mo><mfrac><mtext mathvariant="normal">Sum indicator true score variances</mtext><mtext mathvariant="normal">Sum indicator variances</mtext></mfrac><mo>=</mo><mfrac><mrow><mo>∑</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>η</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mo>∑</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>∑</mo><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup></mrow><mrow><mo>∑</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup><mo>+</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> AVE = \frac{\text{Sum indicator true score variances}}{\text{Sum indicator variances}} =  \frac{\sum Var(\eta_k)}{\sum Var(x_k)} = \frac{\sum\lambda^2_k}{\sum(\lambda^2_k + Var(\varepsilon_k))}</annotation></semantics></math>
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>x</mi><mi>k</mi></msub><annotation encoding="application/x-tex">x_k</annotation></semantics></math>
is standardized (i.e.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Var(x_k) = 1</annotation></semantics></math>)
the denominator reduces to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
and the AVE for a generic construct is:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>V</mi><mi>E</mi><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><mo>∑</mo><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><mo>∑</mo><msubsup><mi>ρ</mi><mrow><msub><mi>x</mi><mi>k</mi></msub><mo>,</mo><mi>η</mi></mrow><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> AVE = \frac{1}{K}\sum \lambda^2_k = \frac{1}{K}\sum \rho_{x_k, \eta}^2</annotation></semantics></math>
As an important consequence, the AVE is closely tied to the communality.
<strong>Communality</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>O</mi><msub><mi>M</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">COM_k</annotation></semantics></math>)
is definied as the proportion of variation in an indicator that is
explained by its common factor. Empirically, it is the square of the
standardized loading of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>’th
indicator
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\lambda^2_k</annotation></semantics></math>).
Since indicators, scores/proxies and subsequently loadings are always
standardized in <strong>cSEM</strong>, the squared loading is simply the
squared correlation between the indicator and its related
construct/common factor. The AVE is also directly related to the
<strong>indicator reliability</strong>, defined as the squared
correlation between an indicator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
and its related proxy true score (see section <a href="#reliability">Reliability</a> below), which is again simply
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\lambda^2_k</annotation></semantics></math>.
Therefore in <strong>cSEM</strong> we always have:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>V</mi><mi>E</mi><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><mo>∑</mo><mi>C</mi><mi>O</mi><msub><mi>M</mi><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><mo>∑</mo><msub><mtext mathvariant="normal">Indicator reliability</mtext><mi>k</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><mo>∑</mo><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mi>K</mi></mfrac><mo>∑</mo><msubsup><mi>R</mi><mi>k</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex"> AVE = \frac{1}{K}\sum COM_k = \frac{1}{K}\sum \text{Indicator reliability}_k = \frac{1}{K}\sum\lambda^2_k =  \frac{1}{K}\sum R^2_k </annotation></semantics></math></p>
</div>
<div class="section level4">
<h4 id="implementation">Implementation<a class="anchor" aria-label="anchor" href="#implementation"></a>
</h4>
<p>The function is implemented as: <code><a href="../reference/calculateAVE.html">calculateAVE()</a></code>.</p>
</div>
<div class="section level4">
<h4 id="see-also">See also<a class="anchor" aria-label="anchor" href="#see-also"></a>
</h4>
<p>The AVE is the basis for the Fornell-Larcker criterion.</p>
</div>
</div>
<div class="section level3">
<h3 id="df">Degrees of freedom<a class="anchor" aria-label="anchor" href="#df"></a>
</h3>
<div class="section level4">
<h4 id="definition-1">Definition<a class="anchor" aria-label="anchor" href="#definition-1"></a>
</h4>
<p>Degrees of freedom are calculated as the difference between the
number of non-redundant free elements of the empirical indicator
correlation matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>
and the model parameters.</p>
<p>Although, composite-based estimators retrieve parameters of the
postulated models by forming composites, which involves the estimation
of weights the computation of the degrees of freedom eventually depends
on the postulated model and the parameters implied by the model. Most
notably, a common factor model estimated by a composite-based approach
such as PLS has the same degrees of freedom compared to e.g., classical
maximum likelihood estimation of the same model.</p>
</div>
<div class="section level4">
<h4 id="formulae-1">Formulae<a class="anchor" aria-label="anchor" href="#formulae-1"></a>
</h4>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="normal">df</mtext></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mrow><mrow><mtext mathvariant="normal"># non-redundant off-diagonal elements of the empirical indicator correlation matrix </mtext><mspace width="0.333em"></mspace></mrow><mi>𝐒</mi></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd><mtd columnalign="left" style="text-align: left"><mo>−</mo><mtext mathvariant="normal"># model parameters</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex"> 
\begin{align} 
\text{df} &amp;= \text{# non-redundant off-diagonal elements of the empirical indicator correlation matrix $\boldsymbol{\mathbf{S}}$} \\
      &amp;- \text{# model parameters}
\end{align}
</annotation></semantics></math></p>
<p>If the model contains only linear terms the model parameters are:</p>
<ul>
<li># free correlations between exogenous constructs</li>
<li># specified correlations between endogenous constructs</li>
<li># structural parameters</li>
</ul>
<p>In addition, for each construct
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>:</p>
<ul>
<li># of loadings if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a common factor</li>
<li># of specified measurement error correlations between items of
constructs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a common factor</li>
<li># of weights of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math><strong>minus 1</strong> if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a composite. One weight per block is fixed and hence not
counted as a model parameter since the variance of the composite is
scaled to be unity.</li>
<li># of non-redundant off-diagonal elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝚺</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\mathbf{\Sigma}}_j</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a composite.</li>
</ul>
<p>If the model contains second-order terms the model parameters are
similar:</p>
<ul>
<li># free correlations between exogenous constructs</li>
<li># specified correlations between endogenous constructs</li>
<li># structural parameters. Note: relations between constructs
measuring/forming the second-order construct are not path!</li>
</ul>
<p>In addition, for each construct
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
(including the second-order constructs):</p>
<ul>
<li># of loadings if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a common factor</li>
<li># of specified measurement error correlations between items of
constructs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a common factor</li>
<li># of weights of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math><strong>minus 1</strong> if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a composite. One weight per block is fixed and hence not
counted as a model parameter since the variance of the composite is
scaled to be unity.</li>
<li># of non-redundant off-diagonal elements of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝚺</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\boldsymbol{\mathbf{\Sigma}}_j</annotation></semantics></math>
if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>j</mi></msub><annotation encoding="application/x-tex">\eta_j</annotation></semantics></math>
is modeled as a composite.</li>
</ul>
<div class="section level5">
<h5 id="notes">Notes<a class="anchor" aria-label="anchor" href="#notes"></a>
</h5>
<ol style="list-style-type: decimal">
<li>If all constructs are allowed to freely covary, i.e., there is no
structural model and no structural parameters, all constructs are
considered exogenous.</li>
<li>If the strucutral model contains nonlinear terms (e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>η</mi><mn>1</mn><mn>2</mn></msubsup><annotation encoding="application/x-tex">\eta^2_1</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mn>1</mn></msub><msub><mi>η</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\eta_1\eta_2</annotation></semantics></math>),
degrees of freedom computation is currently unclear (at least to us). A
warning is printed to inform the user that the calculation is may not be
correct.</li>
</ol>
</div>
</div>
<div class="section level4">
<h4 id="implementation-1">Implementation<a class="anchor" aria-label="anchor" href="#implementation-1"></a>
</h4>
<p>The function is implemented as <code><a href="../reference/calculateDf.html">calculateDf()</a></code>.</p>
</div>
<div class="section level4">
<h4 id="see-also-1">See also:<a class="anchor" aria-label="anchor" href="#see-also-1"></a>
</h4>
<p>Degrees of freedom are required for several <a href="#fit_indices">fit measures</a>.</p>
</div>
</div>
<div class="section level3">
<h3 id="fit_indices">Fit Indices<a class="anchor" aria-label="anchor" href="#fit_indices"></a>
</h3>
<div class="section level4">
<h4 id="definition-2">Definition<a class="anchor" aria-label="anchor" href="#definition-2"></a>
</h4>
<p>Fit indices for confirmatory factor analysis (CFA) were first
introduced by <span class="citation">Bentler and Bonett (1980)</span>.
Since then a large number of indices has been defined. Contrary to exact
tests of model fit, the purpose of fit indices is to measure the fit of
a structural equation model on a continuous scale. For normed fit
indices this scale is between 0 and 1. Fit indices can be divided into
two classes:</p>
<ul>
<li>‘badness of fit’ (resp. ‘lack of fit’) indices; a smaller value
indicates a better fit.</li>
<li>‘goodness of fit’ indices; a higher value represents a better
fit.</li>
</ul>
<p>Several studies have analyzed the empirical and theoretical
properties of fit indices in the context of CFA where concepts are
expressed by latent variables. only little is known about the properties
and the performance of fit indices in composite models and for models
estimated using a composite-based approach. <strong>cSEM</strong> offers
a number of fit indices that are known from factor-based SEM. However,
applied users should be aware that only little is known about their
applicability, intuition, and interpretability in the context of models
containing constructs modeled as composites or for models estimated
using a composite-based approach.</p>
<p>Independent of the approach and model used, a particularily
controversial issue are cutoff values for fit indices <span class="citation">(e.g., Marsh, Hau, and Wen 2004)</span>. In
factor-based SEM cutoff values are rather popular. The basis for these
are numerous simulation studies, most notably <span class="citation">Hu
and Bentler (1999)</span>. In contrast for composite models - for better
or worse - no cutoff values have been suggested.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> Using
<code><a href="../reference/assess.html">assess()</a></code> to calculate fit indices, the user should always
keep in mind that the value of a fit index is just <em>some</em>
indication of good or bad fit. Other aspects related to model fit must
be considered as well. It is unreasonable to make a binary decision
about rejection or non-rejection of a model by soley comparing the value
of a fit index with a (more or less) arbitrary cutoff value.</p>
<p>The definitions of fit indices calculated by <code><a href="../reference/assess.html">assess()</a></code>
are given in the following:</p>
<ul>
<li>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>-<strong>statistic</strong>
is the value of the fitting function times the sample size minus 1.</li>
<li>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup><mi>/</mi><mi>d</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\chi^2/df</annotation></semantics></math>-ratio
is the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>-statistic
divided by its degrees of freedom.</li>
<li>The <strong>goodness-of-fit index</strong> (GFI) measures the
relative increase in fit of the specified model compared to no model at
all.</li>
<li>The <strong>standardized root mean square residual</strong> (SRMR)
is the square root of the mean of squared residual correlations.</li>
<li>The <strong>root mean square error of approximation</strong> (RMSEA)
is the square root of the discrepancy due to approximation per degree of
freedom.</li>
<li>The <strong>normed fit index</strong> (NFI) measures the increase in
fit when specifying the model under consideration relative to the fit of
a certain baseline model called the “null model”.</li>
<li>The <strong>non-normed fit index</strong> (NNFI) accounts for the
degrees of freedom of the involved models. It is the ratio of the
distance between the fit of the baseline model and the fit of the
specified model (each per degree of freedom) and the distance beetween
the fit of the baseline model and the expected fit of the specified
model (each per degree of freedom).</li>
<li>The <strong>comparative fit index</strong> (CFI) estimates the
relative decrease in non-centrality when specifying the model under
consideration instead of the baseline model.</li>
<li>The <strong>incremental fit index</strong> (IFI) is the ratio of the
distance between the fit of the baseline model and the fit of the
specified model and the distance between the fit of the baseline model
and the expected fit of the specified model. Its definition differs only
marginally from the definition of the NNFI.</li>
<li>The <strong>root mean square outer residual covariance</strong>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">RMS</mtext><mi>θ</mi></msub><annotation encoding="application/x-tex">\text{RMS}_{\theta}</annotation></semantics></math>)
is defined as the square root of the mean squared covariances of the
residuals of the outer model. The calculation of the indicator’s
residual covariance matrix involves the calculation of the construct’s
covariance matrix. See <span class="citation">Lohmöller (1989)</span>.
<!-- this is not stated more precisely. That is why, two alternatives are possible: -->
<!--  - the restrictions of the structural model are taken into account basing -->
<!--    the calculation on the model-implied construct covariance matrix. -->
<!--  - the restrictions of the structural are not taken into account basing         -->
<!--    the calculation on the empirical construct covariance matrix, i.e., the -->
<!--    model-implied construct covariance matrix is assumed to be saturated. -->
</li>
</ul>
<p>It should be stressed again that (with the possible exception of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">RMS</mtext><mi>θ</mi></msub><annotation encoding="application/x-tex">\text{RMS}_{\theta}</annotation></semantics></math>)
none of the above mentioned fit indices were originally designed for
composite models. The indices RMSEA and CFI are non-centrality based and
require specific assumptions on model and data typically made in CFA.
The same applies for IFI and NNFI since their calculation relies on the
properties (primarily the expectation) of the test statistic when data
follows a normal distribution. In general, those assumptions are not
made in composite models and composite-based estimators, respectively.
For this reason, the intuition behind these indices does not hold for
composite-based SEM. Nevertheless, calculation of these indices is also
possible in this case. Whether the values of these indices are still
meaningful in a sense that they can be used for assessment of model fit
is an open question. Furthermore, values of fit indices for
composite-based estimators and factor-based estimators may not be
compared. Users should always keep this aspect and the general
limitations of fit indices in mind.</p>
</div>
<div class="section level4">
<h4 id="formulae-2">Formulae<a class="anchor" aria-label="anchor" href="#formulae-2"></a>
</h4>
<p>The exact formulae of the fit indices as implemented in
<strong>cSEM</strong> are given in the following. The term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐒</mi><mo>,</mo><mi>𝚺</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>F</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐒</mi><mo>,</mo><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F = F(\boldsymbol{\mathbf{S}}, \boldsymbol{\mathbf{\Sigma}}(\hat{\boldsymbol{\mathbf{\theta}}})) = F(\boldsymbol{\mathbf{S}}, \hat{\boldsymbol{\mathbf{\Sigma}}})</annotation></semantics></math>
stands for the value of the maximum likelihood fitting function
evaluated at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>
(the empirical covariance matrix of the indicators) and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\mathbf{\Sigma}}}</annotation></semantics></math>
(the estimated model-implied covariance matrix of the indicators). The
value of the maximum likelihood fitting function is computed by
<code><a href="../reference/distance_measures.html">calculateDML()</a></code>.
<!-- In the context of composite-based estimators, the distance measures $d_{G}$  -->
<!-- (geodesic distance), $d_{L}$ (squared Euclidean distance) and $d_{ML}$ -->
<!-- (maximum likelihood distance) serve as fitting functions. --></p>
<div class="section level5">
<h5 id="the-chi2-statistic">The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>-statistic<a class="anchor" aria-label="anchor" href="#the-chi2-statistic"></a>
</h5>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>-<strong>statistic</strong>
is defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>F</mi></mrow><annotation encoding="application/x-tex"> \chi^2 = (N-1)\cdot F</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is the sample size.</p>
<p>Main reference: <span class="citation">K. G. Jöreskog
(1969)</span></p>
</div>
<div class="section level5">
<h5 id="the-chi2textdf-ratio">The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup><mi>/</mi><mtext mathvariant="normal">df</mtext></mrow><annotation encoding="application/x-tex">\chi^2/\text{df}</annotation></semantics></math>-ratio<a class="anchor" aria-label="anchor" href="#the-chi2textdf-ratio"></a>
</h5>
<p>The
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup><mi>/</mi><mtext mathvariant="normal">df</mtext></mrow><annotation encoding="application/x-tex">\chi^2/\text{df}</annotation></semantics></math>-<strong>statistic</strong>
is defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>χ</mi><mn>2</mn></msup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>F</mi><mi>/</mi><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub></mrow><annotation encoding="application/x-tex"> \chi^2 = (N-1)\cdot F/\text{df}_M</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
the sample size and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub><annotation encoding="application/x-tex">\text{df}_M</annotation></semantics></math>
the degrees of freedom of the estimated model.</p>
<p>Main reference: <span class="citation">K. G. Jöreskog
(1969)</span></p>
</div>
<div class="section level5">
<h5 id="the-goodness-of-fit-index-gfi">The goodness-of-fit index (GFI)<a class="anchor" aria-label="anchor" href="#the-goodness-of-fit-index-gfi"></a>
</h5>
<p>The GFI is generally defined in analogy to the coefficient of
determination
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>R</mi><mn>2</mn></msup><annotation encoding="application/x-tex">R^2</annotation></semantics></math>)
known from regression analysis as 1 minus the share of the weighted
unexplained variance (SSE; the difference between
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\mathbf{\Sigma}}}</annotation></semantics></math>)
relative to the weighted total variance (SST; the variance of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>F</mi><mi>I</mi><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mtext mathvariant="normal">trace</mtext><mrow><mo stretchy="true" form="prefix">{</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐖</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mo stretchy="false" form="prefix">[</mo><mi>𝐒</mi><mo>−</mo><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><mo stretchy="false" form="postfix">]</mo><msup><mi>𝐖</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">}</mo></mrow></mrow><mrow><mtext mathvariant="normal">trace</mtext><mrow><mo stretchy="true" form="prefix">{</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐖</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mi>𝐒</mi><msup><mi>𝐖</mi><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo stretchy="true" form="postfix">}</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> GFI = 1 - \frac{\text{trace}\left\{\left(\boldsymbol{\mathbf{W}}^{-\frac{1}{2}}\lbrack\boldsymbol{\mathbf{S}} - \hat{\boldsymbol{\mathbf{\Sigma}}}\rbrack\boldsymbol{\mathbf{W}}^{-\frac{1}{2}}\right)^2\right\}}{\text{trace}\left\{\left(\boldsymbol{\mathbf{W}}^{-\frac{1}{2}}\boldsymbol{\mathbf{S}}\boldsymbol{\mathbf{W}}^{-\frac{1}{2}}\right)^2\right\}} </annotation></semantics></math>
The matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐖</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{W}}</annotation></semantics></math>
is a weight matrix. Depending on the estimation technique used to obtain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝛉</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\mathbf{\theta}}}</annotation></semantics></math>
different types of GFI may be computed by choosing a particular
weight.</p>
<ol style="list-style-type: decimal">
<li>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>=</mo><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">\boldsymbol{\mathbf{W}} = \hat{\boldsymbol{\mathbf{\Sigma}}}</annotation></semantics></math>,
the GFI is based on the SSE and the SST from a maximum likelihood
estimation.</li>
<li>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>=</mo><mover><mi>𝐒</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">\boldsymbol{\mathbf{W}} = \hat{\boldsymbol{\mathbf{S}}}</annotation></semantics></math>,
the GFI is based on SSE and the SST from a generalized least squares
(GLS) estimation.</li>
<li>If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐖</mi><mo>=</mo><mover><mi>𝐈</mi><mo accent="true">̂</mo></mover></mrow><annotation encoding="application/x-tex">\boldsymbol{\mathbf{W}} = \hat{\boldsymbol{\mathbf{I}}}</annotation></semantics></math>,
the GFI is based on SSE and the SST from a unweighted least squares
(ULS) estimation.</li>
</ol>
<p>Note that for any quadratic matrix , we have:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">trace</mtext><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>𝐗</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><msubsup><mi>x</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\text{trace}(\boldsymbol{\mathbf{X}}^2) = \sum_{i,j} x^2_i</annotation></semantics></math>.</p>
<p>Main references: <span class="citation">Karl G. Jöreskog and Sörbom
(1982)</span>, <span class="citation">Mulaik et al. (1989)</span> and
<span class="citation">Tanaka and Huba (1985)</span></p>
</div>
<div class="section level5">
<h5 id="the-standardized-root-mean-square-residual-srmr">The standardized root mean square residual (SRMR)<a class="anchor" aria-label="anchor" href="#the-standardized-root-mean-square-residual-srmr"></a>
</h5>
<p>The SRMR is defined as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SRMR</mtext><mo>=</mo><msqrt><mrow><mn>2</mn><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></munderover><mfrac><mrow><mo stretchy="false" form="prefix">[</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>−</mo><msub><mover><mi>σ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><msub><mi>s</mi><mrow><mi>j</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>1</mn><mi>/</mi><mn>2</mn></mrow></msup><msup><mo stretchy="false" form="postfix">]</mo><mn>2</mn></msup></mrow><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow></msqrt></mrow><annotation encoding="application/x-tex">  \text{SRMR} = \sqrt{2 \sum_{j=1}^{K} \sum_{i=1}^{j} \frac{ \lbrack (s_{ij} - \hat{\sigma}_{ij})/(s_{ii} s_{jj})^{1/2} \rbrack^{2}}{K (K+1)}} </annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
stands for the number of indicators,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">s_{ij}</annotation></semantics></math>
for the empirical covariance between indicators
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>σ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">\hat{\sigma}_{ij}</annotation></semantics></math>
for the estimated model-implied counterpart. The SRMR describes with
which distance the observed correlations are reproduced on average by
the model. Therefore, smaller values are associated with a better fit.
If data is standardized,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mi>i</mi></mrow></msub><mo>=</mo><msub><mi>s</mi><mrow><mi>j</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_{ii} = s_{jj} = 1</annotation></semantics></math>
holds, and the formula reduces to:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">SRMR</mtext><mo>=</mo><msqrt><mrow><mn>2</mn><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>j</mi></munderover><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>−</mo><msub><mover><mi>σ</mi><mo accent="true">̂</mo></mover><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow></msqrt></mrow><annotation encoding="application/x-tex">  \text{SRMR} = \sqrt{2 \sum_{j=1}^{K} \sum_{i=1}^{j} \frac{(s_{ij} - \hat{\sigma}_{ij})^2}{K(K+1)}} </annotation></semantics></math></p>
<p>Main reference: <span class="citation">Bentler (2006)</span></p>
</div>
<div class="section level5">
<h5 id="the-root-mean-square-error-of-approximation-rmsea">The root mean square error of approximation (RMSEA)<a class="anchor" aria-label="anchor" href="#the-root-mean-square-error-of-approximation-rmsea"></a>
</h5>
<p>The RMSEA is defined as <span class="math display">$$ \hat{\epsilon}
= \sqrt{\frac{\hat{F}_0}{\text{df}_{M}}} \quad \text{where} \quad
\hat{F}_{0} = \max \Bigl( 0, F - \frac{\text{df}_{M}}{N-1} \Bigr)
$$</span> In this formula,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub><annotation encoding="application/x-tex">\text{df}_{M}</annotation></semantics></math>
stands for the degrees of freedom of the specified model (see the <a href="#df">Degrees of Freedom</a> section for details on how the degrees
of freedom are calculated). The term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>F</mi><mo accent="true">̂</mo></mover><mn>0</mn></msub><annotation encoding="application/x-tex">\hat{F}_{0}</annotation></semantics></math>
is an estimator for the discrepancy due to approximation. Thus, the
RMSEA measures the discrepancy due to approximation per degree of
freedom.</p>
<p>Main reference: <span class="citation">Browne and Cudeck
(1992)</span></p>
</div>
<div class="section level5">
<h5 id="the-normed-and-non-normed-fit-index-nfi-and-nnfi">The normed and non-normed fit index (NFI and NNFI)<a class="anchor" aria-label="anchor" href="#the-normed-and-non-normed-fit-index-nfi-and-nnfi"></a>
</h5>
<p>The fit indices NFI and NNFI were among the first fit indices to be
introduced <span class="citation">(Bentler and Bonett 1980)</span>. They
are defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">NFI</mtext><mo>=</mo><mfrac><mrow><msub><mi>F</mi><mi>B</mi></msub><mo>−</mo><msub><mi>F</mi><mi>M</mi></msub></mrow><msub><mi>F</mi><mi>B</mi></msub></mfrac><mspace width="1.0em"></mspace><mtext mathvariant="normal">and</mtext><mspace width="1.0em"></mspace><mtext mathvariant="normal">NNFI</mtext><mo>=</mo><mfrac><mrow><msub><mi>F</mi><mi>B</mi></msub><mi>/</mi><msub><mtext mathvariant="normal">df</mtext><mi>B</mi></msub><mo>−</mo><msub><mi>F</mi><mi>M</mi></msub><mi>/</mi><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub></mrow><mrow><msub><mi>F</mi><mi>B</mi></msub><mi>/</mi><msub><mtext mathvariant="normal">df</mtext><mi>B</mi></msub><mo>−</mo><mn>1</mn><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \text{NFI} = \frac{F_{B} - F_{M}}{F_{B}} \quad \text{and} \quad \text{NNFI} = \frac{F_{B}/\text{df}_{B} - F_{M}/\text{df}_{M}}{F_{B}/\text{df}_{B} - 1/(N-1)} </annotation></semantics></math>
The term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>B</mi></msub><annotation encoding="application/x-tex">F_{B}</annotation></semantics></math>
refers to the value of the fitting function in the null model,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>M</mi></msub><annotation encoding="application/x-tex">F_{M}</annotation></semantics></math>
to the value of the fitting function in the model under consideration.
Thus, the NFI measures the increase in fit relative to the fit of the
null model when specifying the model. The intuition of NNFI is that (in
factor-based methods) the expectation of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>M</mi></msub><mi>/</mi><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">F_{M}/\text{df}_{M}</annotation></semantics></math>
is equal to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi>/</mi><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1/N-1</annotation></semantics></math>.
This does not automatically hold for composite-based estimators.</p>
<p>The NNFI measures the relative departure of the numerator’s term from
it’s expectation (in the denominator). That is why, the NNFI is not
normed and can take values larger than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>.</p>
<p>Main reference: <span class="citation">Bentler and Bonett
(1980)</span></p>
</div>
<div class="section level5">
<h5 id="the-comparative-fit-index-cfi">The comparative fit index (CFI)<a class="anchor" aria-label="anchor" href="#the-comparative-fit-index-cfi"></a>
</h5>
<p>The CFI is defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">CFI</mtext><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mo>max</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>F</mi><mi>M</mi></msub><mo>−</mo><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mo>max</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>F</mi><mi>M</mi></msub><mo>−</mo><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub><mo>,</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>F</mi><mi>B</mi></msub><mo>−</mo><msub><mtext mathvariant="normal">df</mtext><mi>B</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \text{CFI} = 1 - \frac{\max(0, (N-1) F_{M}-\text{df}_{M})}{\max(0, (N-1) F_{M}-\text{df}_{M}, (N-1)F_{B}-\text{df}_{B})} </annotation></semantics></math>
Like the RMSEA, the CFI is a non-centrality based index. It measures the
increase in fit (that is to say the reduction in non-centrality) when
specifying the model under consideration relative to the fit of the null
model. The CFI is a normed index with a value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
indicating the best fit. Since it makes use of the assumptions in
factor-based methods, its intuition does not apply to composite-based
estimators.</p>
<p>Main reference: <span class="citation">Bentler (1990)</span>.</p>
</div>
<div class="section level5">
<h5 id="the-incremental-fit-index-ifi">The incremental fit index (IFI)<a class="anchor" aria-label="anchor" href="#the-incremental-fit-index-ifi"></a>
</h5>
<p>The IFI is defined as:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">IFI</mtext><mo>=</mo><mfrac><mrow><msub><mi>F</mi><mi>B</mi></msub><mo>−</mo><msub><mi>F</mi><mi>M</mi></msub></mrow><mrow><msub><mi>F</mi><mi>B</mi></msub><mo>−</mo><mi>d</mi><msub><mi>f</mi><mi>M</mi></msub><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \text{IFI} = \frac{F_{B} - F_{M}}{F_{B} - df_{M}/(N-1)} </annotation></semantics></math>
The rationale underlying the IFI is that the term
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>B</mi></msub><mo>−</mo><msub><mi>F</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">F_{B} - F_{M}</annotation></semantics></math>
(in the numerator) is compared with its expectation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>B</mi></msub><mo>−</mo><msub><mtext mathvariant="normal">df</mtext><mi>M</mi></msub><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">F_{B} - \text{df}_{M}/(N-1)</annotation></semantics></math>
(in the denominator).</p>
<p>Main reference: <span class="citation">Bollen (1989)</span></p>
</div>
<div class="section level5">
<h5 id="the-root-mean-square-outer-residual-covariance">The root mean square outer residual covariance<a class="anchor" aria-label="anchor" href="#the-root-mean-square-outer-residual-covariance"></a>
</h5>
<!-- The $\text{RMS}_{\theta}$ is defined as the square root of the average  -->
<!-- squared covariances of the outer model residuals. Since indicators of  -->
<!-- the same block are allowed to correlate freely in composite models, only the covariances -->
<!-- of residuals of different blocks are included in this case. The calculation of  -->
<!-- $\text{RMS}_{\theta}$ necessitates the calculation of the correlation matrix of  -->
<!-- the residuals which is usually labeled $\Theta$: -->
<!-- $$ \Theta = V(X - \hat{X}) = E((X - \hat{X}) \, (X - \hat{X})')$$ -->
<!-- Since in composite based SEM we always have: $\hat{X} = \hat\Lambda' \hat W X$,  -->
<!-- it follows that: -->
<!-- $$\hat\Theta = S - S \, \hat W' \, \hat\Lambda - (S \, \hat W' \, \hat\Lambda)' + \hat\Lambda' \, V(\hat W X) \, \hat\Lambda$$ -->
<!-- The covariance matrix of the constructs (resp. their proxies) $V(W X)$ can be calculated  -->
<!-- in two ways. On the one hand, the restrictions of the structural can be incorporated.  -->
<!-- This is done by setting the argument `.model_implied` of `assess()` to `TRUE` (the default).  -->
<!-- In this case, the matrix $V(W X)$ is the model-implied construct covariance matrix.  -->
<!-- On the other hand (`.model_implied = FALSE`), the structural restrictions can be neglected. -->
<!-- In this case $V(W X)$ is just the empirical covariance matrix of the constructs, i.e.,  -->
<!-- a saturated structural model is considered. -->
<!-- The literature does not comment on how to calculate $V(W X)$ (see @Lohmoeller1989). -->
<!-- Having set all entries of $\Theta$ that belong to indicators of the same block to `NA`,  -->
<!-- the $\text{RMS}_{\theta}$ is calculated as: -->
<!-- $$ RMS_{\theta} = \sqrt{\frac{1}{n} \sum_{j=1}^{K} \sum_{i=1}^{j-1} \theta_{ji}^{2}} $$ -->
<!-- where $K$ is the number of indicators, $\theta_{ji}$ stands for  -->
<!-- the entry at position $(j,i)$ of the (NA-modified) matrix $\Theta$ and $n$ is  -->
<!-- the number of non-NA entries below the diagonal of $\Theta$. -->
</div>
</div>
<div class="section level4">
<h4 id="implementation-2">Implementation<a class="anchor" aria-label="anchor" href="#implementation-2"></a>
</h4>
<p>The functions are implemented as: <code><a href="../reference/fit_measures.html">calculateChiSquare()</a></code>,
<code><a href="../reference/fit_measures.html">calculateChiSquareDf()</a></code>, <code><a href="../reference/fit_measures.html">calculateCFI()</a></code>,
<code><a href="../reference/fit_measures.html">calculateNFI()</a></code>, <code><a href="../reference/fit_measures.html">calculateNNFI()</a></code>,
<code><a href="../reference/fit_measures.html">calculateIFI()</a></code>, <code><a href="../reference/fit_measures.html">calculateGFI()</a></code>,
<code><a href="../reference/fit_measures.html">calculateRMSEA()</a></code>, <code><a href="../reference/fit_measures.html">calculateRMSTheta()</a></code>,
<code><a href="../reference/fit_measures.html">calculateSRMR()</a></code>.</p>
</div>
<div class="section level4">
<h4 id="see-also-2">See also<a class="anchor" aria-label="anchor" href="#see-also-2"></a>
</h4>
<p>Several fit indices require a fitting function, i.e., a distance
measure like the geodesic distance, the squared Euclidean distance or
the maximum likelihood distance. These are implemented as:
<code><a href="../reference/distance_measures.html">calculateDG()</a></code>, <code><a href="../reference/distance_measures.html">calculateDL()</a></code>, and
<code><a href="../reference/distance_measures.html">calculateDML()</a></code>.</p>
</div>
</div>
<div class="section level3">
<h3 id="reliability">Reliability<a class="anchor" aria-label="anchor" href="#reliability"></a>
</h3>
<div class="section level4">
<h4 id="definition-3">Definition<a class="anchor" aria-label="anchor" href="#definition-3"></a>
</h4>
<p>Reliability is the <strong>consistency of measurement</strong>, i.e.,
the degree to which a hypothetical repetition of the same measure would
yield the same results. As such, reliability is the closeness of a
measure to an error free measure. It is not to be confused with validity
as a perfectly reliable measure may be invalid.</p>
<p>Practically, reliability must be empirically assessed based on a
theoretical framework. The dominant theoretical framework against which
to compare empirical reliability results to is the well-known <a href="https://floschuberth.github.io/cSEM/articles/Terminology.html" class="external-link">true
score</a> framework which provides the foundation for the measurement
model described in the <a href="https://floschuberth.github.io/cSEM/articles/Notation.html" class="external-link">Notation</a>
help file. Based on the true score framework and using the terminology
and notation of the <a href="https://floschuberth.github.io/cSEM/articles/Notation.html" class="external-link">Notation</a>
and <a href="https://floschuberth.github.io/cSEM/articles/Terminology.html" class="external-link">Termniology</a>
help files, reliability of a generic measurement is defined as:</p>
<ol style="list-style-type: decimal">
<li>The amount of proxy true score variance,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>η</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Var(\bar\eta)</annotation></semantics></math>,
relative to the the proxy or test score variance,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>η</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Var(\hat\eta)</annotation></semantics></math>.</li>
<li>This is identical to the squared correlation between the common
factor and its proxy/composite or test score:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>ρ</mi><mrow><mi>η</mi><mo>,</mo><mover><mi>η</mi><mo accent="true">̂</mo></mover></mrow><mn>2</mn></msubsup><mo>=</mo><mi>C</mi><mi>o</mi><mi>r</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>η</mi><mo>,</mo><mover><mi>η</mi><mo accent="true">̂</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\rho_{\eta, \hat\eta}^2 = Cor(\eta, \hat\eta)^2</annotation></semantics></math>.</li>
</ol>
<p>This “kind” of reliability is commonly referred to as
<strong>internal consistency reliability</strong>.</p>
<p>Based on the true score theory three major types of measurement
models are distinguished. Each type implies different assumptions which
give rise to the formulae written below. The well-established names for
the different types of measurement model provide natural naming
candidates for their corresponding (internal consistency) reliabilities
measure:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Parallel</strong> – Assumption:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>η</mi><mi>j</mi></msub><mo>→</mo><msub><mi>λ</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>λ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\eta_{kj} = \eta_j \longrightarrow \lambda_{kj} = \lambda_j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Var(\varepsilon_{kj}) = Var(\varepsilon_j)</annotation></semantics></math>.</li>
<li>
<strong>Tau-equivalent</strong> – Assumption:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>η</mi><mi>j</mi></msub><mo>→</mo><msub><mi>λ</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>λ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\eta_{kj} = \eta_j \longrightarrow \lambda_{kj} = \lambda_j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>l</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Var(\varepsilon_{kj}) \neq Var(\varepsilon_{lj})</annotation></semantics></math>.</li>
<li>
<strong>Congeneric</strong> – Assumption:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>λ</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><msub><mi>η</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\eta_{kj} = \lambda_{kj}\eta_j</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>k</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>≠</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mrow><mi>l</mi><mi>j</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">Var(\varepsilon_{kj}) \neq Var(\varepsilon_{lj})</annotation></semantics></math>.</li>
</ol>
<p>In principal the test score
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>η</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat\eta</annotation></semantics></math>
is a weighted linear combinations of the indicators, i.e., a proxy or
stand-in for the true score/common factor. Historically, however, the
test score is generally assumed to be a simple sum score, i.e., a
weighted sum of indicators with all weights assumed to be equal to one.
Hence, well-known reliability measures such as Jöreskog’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
or Cronbach’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>
are defined with respect to a test score that indeed represents a simple
sum score. Yet, all reliability measures originally developed assuming a
sum score may equally well be computed with respect to a composite,
i.e., a weighted score with weights not necessarily equal to one.</p>
<p>Apart form the distinction between congeneric (i.e., Jöreskog’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>)
and tau-equivalent reliability (i.e., Cronbach’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>)
we therefore distinguish between reliability estimates based on a test
score (composite) that uses the weights of the weight approach used to
obtain <code>.object</code> and a test score (proxy) based on unit
weights. The former is indicated by adding “<strong>weighted</strong>”
to the original name.</p>
</div>
<div class="section level4">
<h4 id="formulae-3">Formulae<a class="anchor" aria-label="anchor" href="#formulae-3"></a>
</h4>
<p>The most general formula for reliability is the <strong>(weighted)
congeneric reliability</strong>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><mo>=</mo><mfrac><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>η</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>η</mi><mo accent="true">̂</mo></mover><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝛌</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mrow><mi>𝐰</mi><mi>′</mi><mi>𝚺</mi><mi>𝐰</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \rho_{C; \text{weighted}} = \frac{Var(\bar\eta)}{Var(\hat\eta_k)} = \frac{(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{\lambda}})^2}{\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{\Sigma}}\boldsymbol{\mathbf{w}}}</annotation></semantics></math>
Assuming
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐰</mi><mo>=</mo><mi>𝛊</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{\mathbf{w}} = \boldsymbol{\mathbf{\iota}}</annotation></semantics></math>,
i.e., unit weights, the “classical” formula for congeneric reliability
(i.e., Jöreskog’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>),
follows:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>C</mi></msub><mo>=</mo><mfrac><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>η</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>η</mi><mo accent="true">̂</mo></mover><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>λ</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>λ</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mover><mi>ε</mi><mo accent="true">‾</mo></mover><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \rho_C = \frac{Var(\bar\eta)}{Var(\hat\eta_k)} = \frac{\left(\sum\lambda_k\right)^2}{\left(\sum\lambda_k\right)^2 + Var(\bar\varepsilon)}</annotation></semantics></math>
Using the assumptions imposed by the tau-equivalent measurement model we
obtain the <strong>(weighted) tau-equivalent reliability, i.e.,
(weighted) Cronbach’s alpha)</strong>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mrow><mi>T</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><mo>=</mo><mfrac><mrow><msup><mi>λ</mi><mn>2</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><mrow><msup><mi>λ</mi><mn>2</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mo>∑</mo><msubsup><mi>w</mi><mi>k</mi><mn>2</mn></msubsup><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ε</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>−</mo><mo>∑</mo><msubsup><mi>w</mi><mi>k</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mo>∑</mo><msubsup><mi>w</mi><mi>k</mi><mn>2</mn></msubsup><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \rho_{T; \text{weighted}}  = \frac{\lambda^2(\sum w_k)^2}{\lambda^2(\sum w_k)^2 + \sum w_k^2Var(\varepsilon_k)}
 = \frac{\bar\sigma_x(\sum w_k)^2}{\bar\sigma_x[(\sum w_k)^2 - \sum w_k^2] + \sum w_k^2Var(x_k)}</annotation></semantics></math>
where we used the fact that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub><mo>=</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda_k = \lambda</annotation></semantics></math>
(tau-equivalence),
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>λ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\lambda^2</annotation></semantics></math>
equals the average covariance between indicators:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>K</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>K</mi><mo>−</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>σ</mi><mrow><mi>k</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\bar\sigma_x = \frac{1}{K(K-1)}\sum^K_{k=1}\sum^K_{l=1} \sigma_{kl}</annotation></semantics></math>
Again, assuming
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_k = 1</annotation></semantics></math>,
i.e., unit weights, the “classical” formula for tau-equivalent
reliability (Cronbach’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>)
follows:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>T</mi></msub><mo>=</mo><mfrac><mrow><msup><mi>λ</mi><mn>2</mn></msup><msup><mi>K</mi><mn>2</mn></msup></mrow><mrow><msup><mi>λ</mi><mn>2</mn></msup><msup><mi>K</mi><mn>2</mn></msup><mo>+</mo><mo>∑</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>ε</mi><mo accent="true">‾</mo></mover><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><msup><mi>K</mi><mn>2</mn></msup></mrow><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mi>K</mi><mn>2</mn></msup><mo>−</mo><mi>K</mi><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mi>K</mi><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \rho_T = \frac{\lambda^2K^2}{\lambda^2K^2 + \sum Var(\bar\varepsilon_k)}
 = \frac{\bar\sigma_xK^2}{\bar\sigma_x[K^2 - K] + K Var(x_k)}</annotation></semantics></math>
Using the assumptions imposed by the parallel measurement model we
obtain the <strong>parallel reliability</strong>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ρ</mi><mi>P</mi></msub><mo>=</mo><mfrac><mrow><msup><mi>λ</mi><mn>2</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><mrow><msup><mi>λ</mi><mn>2</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>ε</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∑</mo><msubsup><mi>w</mi><mi>k</mi><mn>2</mn></msubsup></mrow></mfrac><mo>=</mo><mfrac><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><mrow><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>−</mo><mo>∑</mo><msubsup><mi>w</mi><mi>k</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">]</mo></mrow><mo>+</mo><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>∑</mo><msubsup><mi>w</mi><mi>k</mi><mn>2</mn></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \rho_P = \frac{\lambda^2(\sum w_k)^2}{\lambda^2(\sum w_k)^2 + Var(\varepsilon)\sum w_k^2} = 
 \frac{\bar\sigma_x(\sum w_k)^2}{\bar\sigma_x[(\sum w_k)^2 - \sum w_k^2] + Var(x)\sum w_k^2} </annotation></semantics></math></p>
<p>In <strong>cSEM</strong> indicators are always standardized and
weights are chosen such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mover><mi>η</mi><mo accent="true">̂</mo></mover><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Var(\hat\eta_k) = 1</annotation></semantics></math>.
This is done by scaling the weight vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐰</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{w}}</annotation></semantics></math>
by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝚺</mi><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{\Sigma}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>.
This simplifies the formulae:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><msub><mi>λ</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝛌</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>ρ</mi><mrow><mi>T</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><mo>=</mo><msub><mi>ρ</mi><mrow><mi>P</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mover><mi>ρ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mo>∑</mo><msub><mi>w</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{align}
\rho_{C; \text{weighted}} &amp;= (\sum w_k\lambda_k)^2 = (\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{\lambda}})^2 \\
\rho_{T; \text{weighted}} = \rho_{P; \text{weighted}} &amp;=  \bar\rho_x(\sum w_k)^2 \\
\end{align}
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>ρ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub><mo>=</mo><msub><mover><mi>σ</mi><mo accent="true">‾</mo></mover><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\bar\rho_x = \bar\sigma_x</annotation></semantics></math>
is the average correlation between indicators. Consequently, parallel
and tau-equivalent reliability are always identical in
<strong>cSEM</strong>.</p>
<p>So far formulae have been motivated theoretically. Since
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝚺</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{\Sigma}}</annotation></semantics></math>
is unknown it can be replaced by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>
(the empirical indicator correlation matrix) or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\mathbf{\Sigma}}}</annotation></semantics></math>
(the model-implied indicator correlation matrix), however,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\mathbf{\Sigma}}}</annotation></semantics></math>
are generally not equal. The practical implication is that if
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>C</mi></msub><annotation encoding="application/x-tex">\rho_{C}</annotation></semantics></math>
is computed as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝛌</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{\lambda}})^2</annotation></semantics></math>
using unit weights the weights can in fact be scaled by both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝐒</mi><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{S}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\hat{\boldsymbol{\mathbf{\Sigma}}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>!
Similarly,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><annotation encoding="application/x-tex">\rho_{C; \text{weighted}}</annotation></semantics></math>
can be computed using weights scaled using either
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐒</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{S}}</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\boldsymbol{\mathbf{\Sigma}}}</annotation></semantics></math>.
Consequently there are in fact four types of congeneric reliability
depending the type of weight and the type of scaling for the weights.
Hence, the calculation is of “the” congeneric reliability is always:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝛌</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{\lambda}})^2</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐰</mi><annotation encoding="application/x-tex">\boldsymbol{\mathbf{w}}</annotation></semantics></math>
can be:</p>
<ol style="list-style-type: decimal">
<li>a vector of unit weights scaled by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\hat{\boldsymbol{\mathbf{\Sigma}}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>.
This is typically what people refer to as <em>the</em> congeneric
reliability (Jöreskog’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>).
We label this type of reliability estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>C</mi></msub><annotation encoding="application/x-tex">\rho_C</annotation></semantics></math>.</li>
<li>a vector of unit weights scaled by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝐒</mi><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{S}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>.
This has no known name. Its usefulness is an open question. We label
this type of reliability estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mi>m</mi><mi>m</mi></mrow></msub><annotation encoding="application/x-tex">\rho_{C;mm}</annotation></semantics></math>.</li>
<li>a vector of weights obtained using a composite-based estimator
(e.g. PLS-PM) scaled by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mi>𝐒</mi><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\boldsymbol{\mathbf{S}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>.
This is Dijkstra Henseler’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\rho_A</annotation></semantics></math>.
We label this type of reliability estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><annotation encoding="application/x-tex">\rho_{C;\text{weighted}}</annotation></semantics></math>.</li>
<li>a vector of weights obtained using a composite-based estimator
(e.g. PLS-PM) scaled by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐰</mi><mi>′</mi><mover><mi>𝚺</mi><mo accent="true">̂</mo></mover><mi>𝐰</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></msup><annotation encoding="application/x-tex">(\boldsymbol{\mathbf{w}}'\hat{\boldsymbol{\mathbf{\Sigma}}}\boldsymbol{\mathbf{w}})^{-\frac{1}{2}}</annotation></semantics></math>.
This has no known name. Its usefulness is an open question. We label
this type of reliability estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext><mo>;</mo><mi>m</mi><mi>m</mi></mrow></msub><annotation encoding="application/x-tex">\rho_{C;\text{weighted};mm}</annotation></semantics></math>
</li>
</ol>
<div class="section level5">
<h5 id="a-note-on-the-terminology">A note on the terminology<a class="anchor" aria-label="anchor" href="#a-note-on-the-terminology"></a>
</h5>
<p>A vast bulk of literature dating back to seminal work by Spearman
(e.g., Spearman (1904)) has been written on the subject of reliability.
Inevitably, definitions, formulae, notation and terminology conventions
are unsystematic and confusing. This is particularly true for newcomers
to structural equation modeling or applied users whose primary concern
is to apply the appropriate method to the appropriate case without
poring over books and research papers to understand each intricate
detail.</p>
<p>In <strong>cSEM</strong> we seek to make working with reliabilities
as consistent as possible by relying on a paper by <span class="citation">Cho (2016)</span> who proposed uniform
formula-generating methods and a systematic naming conventions for all
common reliability measures. Naturally, some of the conventional
terminology is deeply entrenched within the nomenclatura of a particular
filed (e.g., coefficient alpha alias Cronbach’s alpha in pychonometrics)
such that a new, albeit consistent, naming scheme seems superfluous at
best. However, we belief the merit of a “standardized” naming pattern
will eventually be helpful to all users as it helps clarify potential
misconceptions thus preventing potential misuse, such as the (ab)use of
Cronbach alpha as a reliability measure for congernic measurement
models.</p>
<p>Apart from these considerations, this package takes a pragmatic
stance in a sense that we use consistent naming because it naturally
provides a consistent naming scheme for the functions and the systematic
formula generating methods because they make code maintenance easier.
Eventually, what matters is the formula and more so its correct
application. To facilitate the translation between different naming
systems and conventions we provide a “translation table” below:</p>
<center>
<table class="table">
<caption>Systematic names and common synonymous names for the
reliability estimates found in the literature</caption>
<colgroup>
<col width="30%">
<col width="27%">
<col width="41%">
</colgroup>
<thead><tr class="header">
<th align="center">Systematic names</th>
<th align="center">Mathematical</th>
<th align="center">Synonymous terms</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="center">Parallel reliability</td>
<td align="center"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>P</mi></msub><annotation encoding="application/x-tex">\rho_P</annotation></semantics></math></td>
<td align="center">Spearman-Brown formula, Spearman-Brown prophecy,
Standardized alpha, Split-half reliability</td>
</tr>
<tr class="even">
<td align="center">Tau-equivalent reliability</td>
<td align="center"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\rho_T</annotation></semantics></math></td>
<td align="center">Cronbach’s alpha,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
Coefficient alpha Guttmans
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mn>3</mn></msub><annotation encoding="application/x-tex">\lambda_3</annotation></semantics></math>,
KR-20</td>
</tr>
<tr class="odd">
<td align="center">Tau-equivalent reliability weighted</td>
<td align="center"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mrow><mi>T</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><annotation encoding="application/x-tex">\rho_{T;\text{weighted}}</annotation></semantics></math></td>
<td align="center">–</td>
</tr>
<tr class="even">
<td align="center">Congeneric reliability</td>
<td align="center"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>C</mi></msub><annotation encoding="application/x-tex">\rho_C</annotation></semantics></math></td>
<td align="center">Composite reliability, Jöreskog’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>,
Construct reliability,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ω</mi><annotation encoding="application/x-tex">\omega</annotation></semantics></math>,
reliability coefficient, Dillon-Goldsteins’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
</td>
</tr>
<tr class="odd">
<td align="center">Congeneric reliability weighted</td>
<td align="center"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mrow><mi>C</mi><mo>;</mo><mtext mathvariant="normal">weighted</mtext></mrow></msub><annotation encoding="application/x-tex">\rho_{C;\text{weighted}}</annotation></semantics></math></td>
<td align="center">Dijkstra-Henseler’s
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ρ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\rho_A</annotation></semantics></math>
</td>
</tr>
</tbody>
</table>
</center>
</div>
<div class="section level5">
<h5 id="closed-form-confidence-interval">Closed-form confidence interval<a class="anchor" aria-label="anchor" href="#closed-form-confidence-interval"></a>
</h5>
<p><span class="citation">Trinchera, Marie, and Marcoulides
(2018)</span> proposed a closed-form confidence interval (CI) for the
tau-equivalent reliability (Cronbach’s alpha). To compute the CI, set
<code>.closed_form_ci = TRUE</code> when calling <code><a href="../reference/assess.html">assess()</a></code>
or invoke <code>calculateRhoT(..., .closed_form_ci = TRUE)</code>
directly. The level of the CI can be changed by supplying a single value
or a vector of values to <code>.alpha</code>.</p>
</div>
</div>
<div class="section level4">
<h4 id="implementation-3">Implementation<a class="anchor" aria-label="anchor" href="#implementation-3"></a>
</h4>
<p>The functions are implemented as <code><a href="../reference/reliability.html">calculateRhoC()</a></code> and
<code><a href="../reference/reliability.html">calculateRhoT()</a></code>.</p>
</div>
</div>
<div class="section level3">
<h3 id="the-goodness-of-fit-gof">The Goodness of Fit (GoF)<a class="anchor" aria-label="anchor" href="#the-goodness-of-fit-gof"></a>
</h3>
<div class="section level4">
<h4 id="definition-4">Definition<a class="anchor" aria-label="anchor" href="#definition-4"></a>
</h4>
<p>Calculate the Goodness of Fit (GoF) proposed by <span class="citation">Tenenhaus, Amanto, and Vinzi (2004)</span>. Note that,
contrary to what the name suggests, the GoF is <strong>not</strong> a
measure of (overall) model fit in a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>χ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\chi^2</annotation></semantics></math>-fit
test sense. See e.g. <span class="citation">Henseler and Sarstedt
(2012)</span> for a discussion.</p>
</div>
<div class="section level4">
<h4 id="formulae-4">Formulae<a class="anchor" aria-label="anchor" href="#formulae-4"></a>
</h4>
<p>The GoF is defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="normal">GoF</mtext><mo>=</mo><msqrt><mrow><mi>⌀</mi><msub><mtext mathvariant="normal">COM</mtext><mi>k</mi></msub><mo>×</mo><mi>⌀</mi><msubsup><mi>R</mi><mrow><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><mn>2</mn></msubsup></mrow></msqrt><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mi>k</mi></mfrac><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msubsup><mi>λ</mi><mi>k</mi><mn>2</mn></msubsup><mo>+</mo><mfrac><mn>1</mn><mi>M</mi></mfrac><munderover><mo>∑</mo><mrow><mi>m</mi><mo>=</mo><mn>1</mn></mrow><mi>M</mi></munderover><msubsup><mi>R</mi><mrow><mi>m</mi><mo>;</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><mn>2</mn></msubsup></mrow></msqrt></mrow><annotation encoding="application/x-tex">\text{GoF} = \sqrt{\varnothing \text{COM}_k \times \varnothing R^2_{structural}} = 
\sqrt{\frac{1}{k}\sum^K_{k=1} \lambda^2_k + \frac{1}{M} \sum^M_{m = 1} R^2_{m;structural}} </annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>O</mi><msub><mi>M</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">COM_k</annotation></semantics></math>
is the communality of indicator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>,
i.e. the variance in the indicator that is explained by its connected
latent variable and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>R</mi><mrow><mi>m</mi><mo>;</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><mn>2</mn></msubsup><annotation encoding="application/x-tex">R^2_{m; structural}</annotation></semantics></math>
the R squared of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>’th
equation of the structural model.</p>
</div>
<div class="section level4">
<h4 id="implementation-4">Implementation<a class="anchor" aria-label="anchor" href="#implementation-4"></a>
</h4>
<p>The function is implemented as: <code><a href="../reference/calculateGoF.html">calculateGoF()</a></code>.</p>
</div>
</div>
<div class="section level3">
<h3 id="the-heterotrait-monotrait-ratio-of-correlations-htmt">The Heterotrait-Monotrait-Ratio of Correlations (HTMT)<a class="anchor" aria-label="anchor" href="#the-heterotrait-monotrait-ratio-of-correlations-htmt"></a>
</h3>
<div class="section level4">
<h4 id="definition-5">Definition<a class="anchor" aria-label="anchor" href="#definition-5"></a>
</h4>
<p>The heterotrait-monotrait ratio of correlations (HTMT) was first
proposed by<br><span class="citation">Henseler, Ringle, and Sarstedt (2015)</span> to
assess convergent and discriminant validity.</p>
</div>
<div class="section level4">
<h4 id="formulae-5">Formulae<a class="anchor" aria-label="anchor" href="#formulae-5"></a>
</h4>
<p>See: <span class="citation">Henseler, Ringle, and Sarstedt
(2015)</span> on page 121 (equation (6))</p>
</div>
<div class="section level4">
<h4 id="implementation-5">Implementation<a class="anchor" aria-label="anchor" href="#implementation-5"></a>
</h4>
<p>The function is implemented as: <code><a href="../reference/calculateHTMT.html">calculateHTMT()</a></code>.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="literature">Literature<a class="anchor" aria-label="anchor" href="#literature"></a>
</h2>
<!-- A third reliability measure is **Parallel reliability** ($\rho_P$), also known -->
<!-- as e.g.: split-half reliability,  -->
<!-- Spearman-Brown formulae/prophecy, standarized alpha. In `cSEM` parallel  -->
<!-- reliability is always identical to tau-equivalent reliability as indicators -->
<!-- are always standardized. Hence, only $\rho_T$ is reported. -->
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-Bentler1990" class="csl-entry">
Bentler, Peter M. 1990. <span>“Comparative <span>Fit</span>
<span>Indexes</span> in <span>Structural</span>
<span>Models</span>.”</span> <em>Psychological Bulletin</em> 107 (2):
238–46.
</div>
<div id="ref-Bentler2006" class="csl-entry">
———. 2006. <em>EQS 6 <span>Structural</span> <span>Equations</span>
<span>Program</span> <span>Manual</span></em> (version 6). Encino, CA:
Multivariate Software, Inc.
</div>
<div id="ref-Bentler1980" class="csl-entry">
Bentler, Peter M., and Douglas G. Bonett. 1980. <span>“Significance
Tests and Goodness of Fit in the Analysis of Covariance
Structures.”</span> <em>Psychological Bulletin</em> 88 (3): 588–606.
</div>
<div id="ref-Bollen1989" class="csl-entry">
Bollen, Kenneth A. 1989. <em>Structural Equations with Latent
Variables</em>. Wiley-Interscience.
</div>
<div id="ref-Browne1992" class="csl-entry">
Browne, Michael W., and Robert Cudeck. 1992. <span>“Alternative
<span>Ways</span> of <span>Assessing</span> <span>Model</span>
<span>Fit</span>.”</span> <em>Sociological Methods &amp; Research</em>
21 (2): 230–58.
</div>
<div id="ref-Cho2016" class="csl-entry">
Cho, Eunseong. 2016. <span>“Making Reliability Reliable.”</span>
<em>Organizational Research Methods</em> 19 (4): 651–82. <a href="https://doi.org/10.1177/1094428116656239" class="external-link">https://doi.org/10.1177/1094428116656239</a>.
</div>
<div id="ref-Fornell1981" class="csl-entry">
Fornell, C., and D. F. Larcker. 1981. <span>“Evaluating Structural
Equation Models with Unobservable Variables and Measurement
Error.”</span> <em>Journal of Marketing Research</em> XVIII: 39–50.
</div>
<div id="ref-Henseler2015" class="csl-entry">
Henseler, Jörg, Christian M. Ringle, and Marko Sarstedt. 2015. <span>“A
New Criterion for Assessing Discriminant Validity in Variance-Based
Structural Equation Modeling.”</span> <em>Journal of the Academy of
Marketing Science</em> 43 (1): 115–35. <a href="https://doi.org/10.1007/s11747-014-0403-8" class="external-link">https://doi.org/10.1007/s11747-014-0403-8</a>.
</div>
<div id="ref-Henseler2012a" class="csl-entry">
Henseler, Jörg, and Marko Sarstedt. 2012. <span>“Goodness-of-Fit Indices
for Partial Least Squares Path Modeling.”</span> <em>Computational
Statistics</em> 28 (2): 565–80. <a href="https://doi.org/10.1007/s00180-012-0317-1" class="external-link">https://doi.org/10.1007/s00180-012-0317-1</a>.
</div>
<div id="ref-Hu1999" class="csl-entry">
Hu, Li-tze, and Peter M. Bentler. 1999. <span>“Cutoff Criteria for Fit
Indexes in Covariance Structure Analysis: Conventional Criteria Versus
New Alternatives.”</span> <em>Structural Equation Modeling</em> 6 (1):
1–55.
</div>
<div id="ref-Joereskog1969" class="csl-entry">
Jöreskog, K. G. 1969. <span>“A General Approach to Confirmatory Maximum
Likelihood Factor Analysis.”</span> <em>Psychometrika</em> 34 (2):
183–202. <a href="https://doi.org/10.1007/bf02289343" class="external-link">https://doi.org/10.1007/bf02289343</a>.
</div>
<div id="ref-Joereskog1982" class="csl-entry">
Jöreskog, Karl G., and Dag Sörbom. 1982. <span>“Recent Developments in
Structural Equation Modeling.”</span> <em>Journal of Marketing
Research</em> 19 (4): 404–16.
</div>
<div id="ref-Lohmoeller1989" class="csl-entry">
Lohmöller, Jan-Bernd. 1989. <em>Latent Variable Path Modeling with
Partial Least Squares</em>. Physica, Heidelberg.
</div>
<div id="ref-Marsh2004" class="csl-entry">
Marsh, Herbert W., Kit-Tai Hau, and Zhonglin Wen. 2004. <span>“In Search
of Golden Rules: Comment on Hypothesis-Testing Approaches to Setting
Cutoff Values for Fit Indexes and Dangers in Overgeneralizing Hu and
Bentler’s (1999) Findings.”</span> <em>Structural Equation Modeling: A
Multidisciplinary Journal</em> 11 (3): 320–41. <a href="https://doi.org/10.1207/s15328007sem1103_2" class="external-link">https://doi.org/10.1207/s15328007sem1103_2</a>.
</div>
<div id="ref-Mulaik1989" class="csl-entry">
Mulaik, Stanley A., Larry R. James, Judith Van Alstine, Nathan Bennett,
Sherri Lind, and C. Dean Stilwell. 1989. <span>“Evaluation of
Goodness-of-Fit Indices for Structural Equation Models.”</span>
<em>Psychological Bulletin</em> 105 (3): 430–45. <a href="https://doi.org/10.1037/0033-2909.105.3.430" class="external-link">https://doi.org/10.1037/0033-2909.105.3.430</a>.
</div>
<div id="ref-Sharma2019" class="csl-entry">
Sharma, Pratyush, Marko Sarstedt, Galit Shmueli, Kevin H. Kim, and Kai
O. Thiele. 2019. <span>“<span>PLS</span>-Based Model Selection: The Role
of Alternative Explanations in Information Systems Research.”</span>
<em>Journal of the Association for Information Systems</em> 20 (4).
</div>
<div id="ref-Tanaka1985" class="csl-entry">
Tanaka, J. S., and G. J. Huba. 1985. <span>“A Fit Index for Covariance
Structure Models Under Arbitrary <span>GLS</span> Estimation.”</span>
<em>British Journal of Mathematical and Statistical Psychology</em> 38
(2): 197–201. <a href="https://doi.org/10.1111/j.2044-8317.1985.tb00834.x" class="external-link">https://doi.org/10.1111/j.2044-8317.1985.tb00834.x</a>.
</div>
<div id="ref-Tenenhaus2004" class="csl-entry">
Tenenhaus, Michel, Silvano Amanto, and Vincenzo Esposito Vinzi. 2004.
<span>“A Global Goodness-of-Fit Index for <span>PLS</span> Structural
Equation Modelling.”</span> In <em>Proceedings of the <span>XLII
SIS</span> Scientific Meeting</em>, 739–42.
</div>
<div id="ref-Trinchera2018" class="csl-entry">
Trinchera, Laura, Nicolas Marie, and George A. Marcoulides. 2018.
<span>“A Distribution Free Interval Estimate for Coefficient
Alpha.”</span> <em>Structural Equation Modeling: A Multidisciplinary
Journal</em> 25 (6): 876–87. <a href="https://doi.org/10.1080/10705511.2018.1431544" class="external-link">https://doi.org/10.1080/10705511.2018.1431544</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>There are some cutoffs such as e.g., the SRMR should be
less than 0.08 or 0.1, however, these values are essentially arbitrary
as they have never been formally motivated. Reference is usually done to
<span class="citation">Hu and Bentler (1999)</span> which based the
cut-off on a simulation using factor-based SEM.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

      </div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Manuel E. Rademaker, Florian Schuberth.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.9000.</p>
</div>

      </footer>
</div>






  </body>
</html>
