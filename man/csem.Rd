% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00_cca.R, R/00_csem.R
\name{csem}
\alias{csem}
\alias{cca}
\title{Composite based SEM and CCA}
\usage{
cca(
  .data             = NULL,
  .model            = NULL,
  .id               = NULL,
  .approach_weights = c("PLS-PM", "SUMCORR", "MAXVAR", "SSQCORR", "MINVAR", "GENVAR", "GSCA", 
                        "fixed", "unit"),
  ...)

csem(
  .data             = NULL,
  .model            = NULL,
  .id               = NULL,
  .approach_2ndorder= c("3stage", "repeated_indicators"),
  .approach_weights = c("PLS-PM", "SUMCORR", "MAXVAR", "SSQCORR", "MINVAR", "GENVAR", "GSCA", 
                        "fixed", "unit"),
  .approach_path    = c("OLS", "2SLS", "3SLS"),
  ...
  )
}
\arguments{
\item{.data}{A \code{data.frame} or a \code{matrix} containing the raw data. Additionally,
a list of \code{data.frame}(s) or \code{matrices} is accepted in which case estimation
is repeated for each data set. See details.}

\item{.model}{A model in \code{\link[lavaan:model.syntax]{lavaan model syntax}}
or a \link{cSEMModel}-list.}

\item{.id}{Character string. The name of the column of \code{.data} used to split
the data into groups. Defaults to \code{NULL}.}

\item{.approach_weights}{Character string. Approach used to
obtain composite weights. One of: "\emph{PLS-PM}", "\emph{SUMCORR}", "\emph{MAXVAR}",
"\emph{SSQCORR}", "\emph{MINVAR}", "\emph{GENVAR}", "\emph{GSCA}", "\emph{fixed}", or "\emph{unit}".
Defaults to "\emph{PLS-PM}".}

\item{...}{Further arguments to be passed down to lower level functions of \code{csem()}
or \code{cca()}. Type \code{\link[cSEM:args_default]{args_default(.only_dots = TRUE)}}
or \code{\link[cSEM:args_default]{args_default(.only_dots = TRUE, .which_fun = "cca")}}
for a complete list of accepted \code{...} arguments for the respective function.}

\item{.approach_2ndorder}{Character string. Approach used for models containing
second order constructs. One of: "\emph{3stage}" or "\emph{repeated_indicators}".
Defaults to "\emph{3stage}".}

\item{.approach_paths}{Character string. Approach used to estimate the
structural coefficients. One of: "\emph{OLS}" or "\emph{2SLS}".
Defaults to "\emph{OLS}".}

\item{.resample_method}{Character string. The resampling method to use. One of:
"\emph{bootstrap}" or "\emph{jackknife}". Defaults to "\emph{bootstrap}".}

\item{.resample_method2}{Character string. The resampling method to use when resampling
from a resample. One of: "\emph{none}", "\emph{bootstrap}" or "\emph{jackknife}". For
\emph{bootstrap} the number of draws may be provided via \code{.R2}.
Defaults to "\emph{none}".}

\item{.R}{Integer. The number of bootstrap replications. Defaults to \code{499}.}

\item{.R2}{Integer. The number of bootstrap replications to use when
resampling from a resample. Defaults to \code{199}.}

\item{.handle_inadmissibles}{Character string. How should inadmissible results
be treated? One of "\emph{drop}", "\emph{ignore}", or "\emph{replace}". If "\emph{drop}", all
replications/resamples yielding an inadmissible result will be dropped (
number of results shown <= .R). For "\emph{ignore}" all results are returned
even if they are inadmissible (number of results = .R). For "\emph{replace}"
resampling continues until there are exactly .R admissible solutions.
Defaults to "\emph{drop}".}

\item{.user_funs}{A function or a (named) list of functions to apply to every
resample. Takes \code{.object} as an input:
\code{myFun <- function(.object) {...}}.  Output should preferably be a (named)
vector but matrices are also accepted. Note however that output will be
vectorized (columnwise) in this case.}

\item{.eval_plan}{Character string. The evaluation plan to use. One of
\emph{sequential} or \emph{multiprocess}. In the latter case
all available cores will be used. Defaults to \emph{sequential}.}
}
\value{
An object of class \code{cSEMResults} with methods for all postestimation generics:
\describe{
\item{\code{check.cSEMResults}}{Checks results using common indices and fit measures.}
\item{\code{fit.cSEMResults}}{Compute the model-implied covariance matrix.}
\item{\code{summarize.cSEMResults}}{Summarize the results.}
\item{\code{test.cSEMResults}}{Run tests.}
\item{\code{verify.cSEMResults}}{Verify admissibility (e.g., loadings larger than one).}
}
The structure of the \code{cSEMResults} object is determined by the data set provided
or more precisely the number of estimation runs performed.

If data is a single matrix or data frame with no id-column, the result is a list with elements:
\describe{
\item{\code{$Estimates}}{A list containing a list of estimated quantities.}
\item{\code{$Information}}{A list containing a list of additional information.}
}

If \code{.data} contains an id-column to split the data by or if a list of
data sets is provided, the results contains \code{n} list with elements \code{$Estimates}
and \code{$Informations} where \code{n} is equal to the number of groups or the number of
data sets in the list of data sets provided.
}
\description{
Estimate linear and nonlinear structural equation models using a
composite based approach or conduct confirmatory composite analysis (CCA).
}
\details{
\code{csem()} estimates linear and nonlinear structural equation models using a
composite based approach like PLS-PM, GSCA or unit weights. Technically, \code{csem()} is a wrapper
around the more general \code{\link[=foreman]{foreman()}} function designed for quick and flexible
use by providing the user with default options except for
the mandatory \code{.data} and \code{.model} argument.

\code{cca()} performs CCA. CCA and SEM differ in that the former allows all
constructs to vary freely. Hence, \code{cca()} is technically a simple convenience wrapper
around \code{csem(..., .estimate_structural = FALSE)}.

\subsection{Data and model:}{
The \code{.data} and \code{.model} arguments are required. Data must be
provided as either a \code{matrix} or a \code{data.frame} with column names matching
the indicator names used in the model description of the measurement model.
Alternatively, a list of matrices or \code{data.frame}s may be provided
in which case estimation is repeated for each data set.
The data provided via \code{.data} may contain a non numeric column whose column name
must be provided to \code{.id}. Values of this column are interpreted as group
identifiers and \code{csem()} or \code{cca()} will split the data by levels of that column and run
the estimation for each level separately.

To provide a model use the \code{\link[lavaan:model.syntax]{lavaan model syntax}}
with two notable extensions/changes. First: the "\code{<~}" operator in \code{cSEM} is
used to define a composite instead of a formative common factor. Second:
the "\code{.}" is used to indicate interactions between constructs as in e.g.,
\code{construct1.construct2}. Alternatively a standardized (possibly incomplete)
\link{cSEMModel}-list may be supplied.
}

\subsection{Weights and path coefficients:}{
By default weights are estimated using the partial least squares algorithm (\emph{PLS-PM}).
Alternative approaches include all of \emph{Kettenring's criteria}, "\emph{fixed weights}"
or "\emph{unit weight}". \emph{Generalized Structured Component Analysis} (\emph{GSCA}) may
also be chosen as a weighing approach although technically GSCA obtains weight
and structural coefficient estimates simultaneously. Hence, setting
\code{.approach_weights = "GSCA"} automatically sets \code{.approach_paths = "GSCA"} (and
vice-versa).

For PLS-PM composite-indicator and composite-composite correlations are properly
rescaled using \emph{PLSc} \insertCite{Dijkstra2015}{cSEM} by default. \emph{PLSc} yields
consistent estimates for the factor loadings, construct correlations,
and path coefficients if any of the constructs involved is
modeled as a common factor. Disattenuation my be suppressed by setting
\code{.disattenuate = FALSE}. Note however that quantities in this case are inconsistent
estimates for their construct level counterparts if any of the constructs is
the model as a common factor.
}

\subsection{Non linear models:}{
If the model is nonlinear \code{csem()} estimates a polynomial structural equation model
using a non-iterative method of moments approach described in
\insertCite{Dijkstra2014}{cSEM}. Non linear terms include interactions and
exponential terms. The latter is described in model syntax as an
"interaction with itself", e.g., \code{x_1^3 = x1.x1.x1}. Currently only exponential
terms up to a power of three (i.e. three-way interactions) are allowed.

The current version of the package allows two kinds of estimation:
estimation of the reduced form equation (\code{.approach_nl = "reduced"}) and
sequential estimation (\code{.approach_nl = "sequential"}). The latter does not
not allow for multivariate normality of all exogenous variables, i.e.,
the latent variables and the error terms.

Distributional assumptions are kept to a minimum (an i.i.d. sample from a
population with finite moments for the relevant order); for higher order models,
that go beyond interaction, we work in this version with the assumption that
as far as the relevant moments are concerned certain combinations of
measurement errors behave as if they were Gaussian.
}
}
\examples{
\dontrun{
# TODO
}

}
\references{
\insertAllCited{}
}
\seealso{
\link{args_default}, \link{cSEMArguments}, \link{cSEMResults}, \link{foreman}
}
